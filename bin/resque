#!/usr/bin/env php
<?php

// Find and initialize Composer

use Psr\Log\LogLevel;
use Resque\Redis;
use Resque\Resque;

$files = [
    __DIR__ . '/../../vendor/autoload.php',
    __DIR__ . '/../../../autoload.php',
    __DIR__ . '/../../../../autoload.php',
    __DIR__ . '/../vendor/autoload.php',
];

foreach ($files as $file) {
    if (file_exists($file)) {
        require_once $file;
        break;
    }
}

if (!class_exists('Composer\Autoload\ClassLoader', false)) {
    die(
        'You need to set up the project dependencies using the following commands:' . PHP_EOL .
        'curl -s http://getcomposer.org/installer | php' . PHP_EOL .
        'php composer.phar install' . PHP_EOL
    );
}

// Set which queues to monitor '*'
$queue = getenv('QUEUE');
if (empty($queue)) {
    die("Set QUEUE env var containing the list of queues to work.\n");
}

/**
 * REDIS_BACKEND can have simple 'host:port' format or use a DSN-style format like this:
 * - redis://user:pass@host:port
 *
 * Note: the 'user' part of the DSN URI is required but is not used.
 */
$redisBackend = getenv('REDIS_BACKEND');

/**
 * REDIS_BACKEND_DB overrides default Redis DB
 */
$redisBackendDb = getenv('REDIS_BACKEND_DB');
if (!empty($redisBackend)) {
    if (empty($redisBackendDb)) {
        \Resque\Resque::setBackend($redisBackend);
    } else {
        \Resque\Resque::setBackend($redisBackend, $redisBackendDb);
    }
}

// Set Logging level - Default to INFO
$logLevel = getenv('LOGLEVEL');
if (!in_array($logLevel, [
    LogLevel::DEBUG,
    LogLevel::INFO,
    LogLevel::NOTICE,
    LogLevel::WARNING,
    LogLevel::ERROR,
    LogLevel::CRITICAL,
    LogLevel::ALERT,
    LogLevel::EMERGENCY,
])) {
    $logLevel = LogLevel::INFO;
}

// Bootstrap file
$appInclude = getenv('APP_INCLUDE');
if ($appInclude) {
    if (!file_exists($appInclude)) {
        die('APP_INCLUDE file (' . $appInclude . ") does not exist.\n");
    }

    require_once $appInclude;
}

// See if the APP_INCLUDE containes a $logger object, if none exists, fallback to internal logger
if (!isset($logger) || !is_object($logger)) {
    $logger = new \Resque\Log($logLevel);
}

// Determines if blocking or not
$blocking = getenv('BLOCKING') !== FALSE;
$logger->log(LogLevel::DEBUG, 'Blocking set to {blocking}', ['blocking' => $blocking]);

// Interval to check for jobs
$interval = (int) getenv('INTERVAL');
if (empty($interval) || $interval <= 0) {
    $interval = Resque::DEFAULT_INTERVAL;
}
$logger->log(LogLevel::DEBUG, 'Interval set to {interval}', ['interval' => $interval]);

// Set worker count
$count = (int) getenv('COUNT');
if (empty($count) || $count < 1) {
    $count = 1;
}
$logger->log(LogLevel::DEBUG, 'Worker count set to {count}', ['count' => $count]);

// Set redis key prefix
$redisPrefix = getenv('PREFIX');
if (empty($redisPrefix)) {
    $redisPrefix = 'phpresque:';
}
Redis::prefix($redisPrefix);
$logger->log(LogLevel::DEBUG, 'Redis prefix set to {prefix}', ['prefix' => $redisPrefix]);

// Start workers
if ($count > 1) {
    for ($i = 0; $i < $count; ++$i) {
        $pid = \Resque\Resque::fork();
        if ($pid === false || $pid === -1) {
            // Parent, failed to fork child
            $logger->log(LogLevel::EMERGENCY, 'Could not fork worker {count} - exiting', ['count' => $i]);
            die();
        } elseif (!$pid) {
            // Child, start the worker
            $queues = explode(',', $queue);
            $worker = new \Resque\Worker($queues);
            $worker->setLogger($logger);
            $logger->log(LogLevel::NOTICE, 'Starting worker {worker}', ['worker' => $worker]);
            $worker->work($interval, $blocking);
            break;
        }
    }
} else {
    // Start a single worker
    $queues = explode(',', $queue);
    $worker = new \Resque\Worker($queues);
    $worker->setLogger($logger);

    $pidFile = getenv('PIDFILE');
    if ($pidFile) {
        if (!file_put_contents($pidFile, getmypid())) {
            $logger->log(LogLevel::ERROR, 'Could not write PID information to {pidFile}', ['pidFile' => $pidFile]);
            die();
        }
        $logger->log(LogLevel::DEBUG, 'PID file {pidFile} written', ['pidFile' => $pidFile]);
    }

    $logger->log(LogLevel::NOTICE, 'Starting worker {worker}', ['worker' => $worker]);
    $worker->work($interval, $blocking);
}
